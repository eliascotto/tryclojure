{"version":3,"sources":["markdown/tables.cljc"],"mappings":"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","names":["markdown.tables/parse-table-row","text","p1__57501#","cljs.core._EQ_","cljs.core/first","cljs.core.apply","cljs.core/str","cljs.core/rest","clojure.string/trim","p1__57502#","clojure.string.split","cljs.core.map","p1__57503#","cljs.core/identity","markdown.tables/table-row->str","row-data","is-header?","cljs.core.reduce","row","col","alignment-str","cljs.core/name","markdown.tables/table->str","table","table-data","cljs.core.map_indexed","cljs.core/vector","alignment-seq","table-acc","row-idx","cljs.core.mapv","cljs.core/merge","cljs.core/second","is-first-row?","is-last-row?","cljs.core/count","markdown.tables/divider-seq->alignment","divider-seq","divider","cljs.core/re-find","markdown.tables/table","state","table-row-re","table-divider-re","is-table-row?","is-table-header?","cljs.core/not","cljs.core.get_in","is-table-divider?","and__4251__auto__","header-seq","cljs.core/assoc-in","cljs.core.update_in","cljs.core.fnil","cljs.core/conj","cljs.core/vec","row-seq","out","cljs.core/empty?","cljs.core.dissoc"],"sourcesContent":["(ns markdown.tables\n  (:require [clojure.string :as string]))\n\n(defn parse-table-row [text]\n  (->> text\n       (#(if (= (first %) \\|)\n          (apply str (rest %))\n          %))\n       (string/trim)\n       (#(string/split % #\"\\|\"))\n       (map string/trim)\n       (map #(identity {:text %}))))\n\n(defn table-row->str [row-data is-header?]\n  (reduce\n    (fn [row col]\n      (let [alignment-str (when (:alignment col)\n                            (str \" style='text-align:\" (name (:alignment col)) \"'\"))]\n        (if is-header?\n          (str row \"<th\" alignment-str \">\" (:text col) \"</th>\")\n          (str row \"<td\" alignment-str \">\" (:text col) \"</td>\"))))\n    \"\"\n    row-data))\n\n(defn table->str [table]\n  (let [table-data (map-indexed vector (:data table))\n        alignment-seq (:alignment-seq table)]\n    (str \"<table>\"\n         (reduce\n           (fn [table-acc row]\n             (let [row-idx (first row)\n                   row-data (mapv merge (second row) alignment-seq)\n                   is-header? (= row-idx 0)\n                   is-first-row? (= row-idx 1)\n                   is-last-row? (= row-idx (dec (count table-data)))]\n               (str\n                 table-acc\n                 (cond\n                   is-header?\n                   \"<thead>\"\n                   is-first-row?\n                   \"<tbody>\")\n                 \"<tr>\"\n                 (table-row->str row-data is-header?)\n                 \"</tr>\"\n                 (cond\n                   is-header?\n                   \"</thead>\"\n                   is-last-row?\n                   \"</tbody>\"))))\n           \"\"\n           table-data)\n         \"</table>\")))\n\n(defn divider-seq->alignment [divider-seq]\n  (mapv (fn [divider]\n          (cond\n            (= (re-find #\"^:-+\" (:text divider))\n               (:text divider))\n            (identity {:alignment :left})\n\n            (= (re-find #\"^-+:\" (:text divider))\n               (:text divider))\n            (identity {:alignment :right})\n\n            (= (re-find #\"^:-+:\" (:text divider))\n               (:text divider))\n            (identity {:alignment :center})\n\n            :else\n            nil))\n        divider-seq))\n\n(defn table [text state]\n  (let [table-row-re (re-find #\"\\|(?: [\\S ]+ \\|)+\" text)\n        table-divider-re (re-find #\"\\|(?: ?:?-+:? ?\\|)+\" text)\n        is-table-row? (= table-row-re text)\n        is-table-header?\n        (and is-table-row?\n             (not (get-in state [:table :in-table-body?])))\n        is-table-divider?\n        (and (= table-divider-re text)\n             (get-in state [:table :in-table-body?])\n             (get-in state [:table :is-prev-header?]))]\n    (cond\n      is-table-header?\n      (let [header-seq (parse-table-row text)]\n        [\"\" (-> state\n                (assoc-in [:table :is-prev-header?] true)\n                (assoc-in [:table :in-table-body?] true)\n                (update-in [:table :data] (fnil conj []) (vec header-seq)))])\n\n      is-table-divider?\n      (let [divider-seq (parse-table-row text)]\n        [\"\" (-> state\n                (assoc-in [:table :is-prev-header?] false)\n                (assoc-in [:table :alignment-seq]\n                          (divider-seq->alignment divider-seq)))])\n\n      is-table-row?\n      (let [row-seq (parse-table-row text)]\n        [\"\" (-> state\n                (assoc-in [:table :is-prev-header?] false)\n                (update-in [:table :data] (fnil conj []) (vec row-seq)))])\n\n      :else\n      (let [out (if (empty? (get-in state [:table :data]))\n                  text\n                  (str (table->str (:table state)) text))]\n        [out (dissoc state :table)]))))\n"]}