{"version":3,"sources":["markdown/common.cljc"],"mappings":"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","names":["markdown.common/*inhibit-separator*","markdown.common/escape-delimiter","cljs.core/char","markdown.common/gen-token","n","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","markdown.common/freeze-string","seq57506","self__4852__auto__","cljs.core/seq","args","state","cljs.core/last","token","cljs.core/count","cljs.core/assoc-in","cljs.core.reduce","cljs.core/str","cljs.core/flatten","cljs.core.drop_last","markdown.common/thaw-string","text","temp__5751__auto__","matches","cljs.core/re-seq","cljs.core/re-pattern","s","r","p1__57511#","clojure.string/replace","cljs.core.get","p1__57512#","cljs.core.update","cljs.core.apply","cljs.core/dissoc","markdown.common/thaw-strings","cljs.core/empty?","markdown.common/escape-code","markdown.common/escaped-chars","or__4253__auto__","markdown.common/open-html-tags","open?","token-seq","cljs.core._EQ_","G__57513","G__57515","markdown.common/make-separator","js/Error","separator","open","close","markdown.common.make_separator","cljs.core/identity","transformer","out","buf","tokens","cljs.core.partition_by","cljs.core.partial","cljs.core/=","cljs.core/first","cur-state","cljs.core.assoc","clojure.string.join","cljs.core.into","cljs.core.dissoc","vec__57524","cljs.core.nth","new-buf","new-state","vec__57527","G__57530","G__57531","cljs.core/vec","cljs.core.concat","cljs.core/rest","cljs.core/not","markdown.common/escape-code-transformer","markdown.common/separator","escape?","markdown.common/strong","markdown.common/bold-italic","markdown.common/bold","markdown.common/em","markdown.common/italics","markdown.common/strikethrough","markdown.common/inline-code","markdown.common/inhibit","markdown.common/escape-inhibit-separator","markdown.common/heading-text","clojure.string/trim","markdown.common/heading-level","num-hashes","p1__57532#","cljs.core.filter","cljs.core.not_EQ_","p1__57533#","cljs.core.take_while","markdown.common/make-heading","heading-anchors","temp__5753__auto__","heading","clojure.string/lower-case","markdown.common/dashes"],"sourcesContent":["(ns markdown.common\n  (:require [clojure.string :as string]))\n\n(def ^{:dynamic true} *substring*)\n\n(def ^:dynamic *inhibit-separator* nil)\n\n(def escape-delimiter (str (char 254) (char 491)))\n\n(defn gen-token [n]\n  (str escape-delimiter n escape-delimiter))\n\n(defn freeze-string\n  \"Freezes an output string.  Converts to a placeholder token and puts that into the output.\n  Returns the [text, state] pair.  Adds it into the state, the 'frozen-strings' hashmap\n  So that it can be unfrozen later.\"\n  [& args]\n  (let [state (last args)\n        token (gen-token (count (:frozen-strings state)))]\n    [token (assoc-in state\n                     [:frozen-strings token]\n                     (reduce str (flatten (drop-last args))))]))\n\n(defn thaw-string\n  \"Recursively replaces the frozen strings in the output with the original text.\"\n  [text state]\n  (if-let [matches (re-seq (re-pattern (str escape-delimiter \"\\\\d+\" escape-delimiter)) text)]\n    (recur\n      (reduce\n        (fn [s r]\n          (string/replace s (re-pattern r) #(get (:frozen-strings state) % %)))\n        text matches)\n      (update state :frozen-strings #(apply dissoc % matches)))\n    [text state]))\n\n(defn thaw-strings\n  \"Terminally encoded strings are ones that we've determined should no longer be processed or evaluated\"\n  [text state]\n  (if-not (empty? (:frozen-strings state))\n    (thaw-string text state)\n    [text state]))\n\n(defn escape-code [s]\n  (-> s\n      (string/replace #\"&\" \"&amp;\")\n      (string/replace #\"\\*\" \"&#42;\")\n      (string/replace #\"\\^\" \"&#94;\")\n      (string/replace #\"\\_\" \"&#95;\")\n      (string/replace #\"\\~\" \"&#126;\")\n      (string/replace #\"\\<\" \"&lt;\")\n      (string/replace #\"\\>\" \"&gt;\")\n      ;(string/replace #\"\\/\" \"&frasl;\") ;screws up ClojureScript compiling\n      (string/replace #\"\\[\" \"&#91;\")\n      (string/replace #\"\\]\" \"&#93;\")\n      (string/replace #\"\\(\" \"&#40;\")\n      (string/replace #\"\\)\" \"&#41;\")\n      (string/replace #\"\\\"\" \"&quot;\")))\n\n(defn escaped-chars [text state]\n  [(if (or (:code state) (:codeblock state))\n     text\n     (-> text\n         (string/replace #\"\\\\\\\\\" \"&#92;\")\n         (string/replace #\"\\\\`\" \"&#8216;\")\n         (string/replace #\"\\\\\\*\" \"&#42;\")\n         (string/replace #\"\\\\_\" \"&#95;\")\n         (string/replace #\"\\\\\\{\" \"&#123;\")\n         (string/replace #\"\\\\\\}\" \"&#125;\")\n         (string/replace #\"\\\\\\[\" \"&#91;\")\n         (string/replace #\"\\\\\\]\" \"&#93;\")\n         (string/replace #\"\\\\\\(\" \"&#40;\")\n         (string/replace #\"\\\\\\)\" \"&#41;\")\n         (string/replace #\"\\\\#\" \"&#35;\")\n         (string/replace #\"\\\\\\+\" \"&#43;\")\n         (string/replace #\"\\\\-\" \"&#45;\")\n         (string/replace #\"\\\\\\.\" \"&#46;\")\n         (string/replace #\"\\\\!\" \"&#33;\")\n         (string/replace #\"\\\\\\^\" \"&#94;\")))\n   state])\n\n(defn open-html-tags [open? token-seq]\n  (= :open (reduce (fn [state token]\n                     (case token\n                       \\< :open\n                       \\> :closed\n                       state))\n                   (if open? :open :closed)\n                   token-seq)))\n\n(defn make-separator\n  \"Return a transformer to\n   - find all the chunks of the string delimited by the `separator',\n   - wrap the output with the `open' and `close' markers, and\n   - apply the `transformer' to the text inside the chunk.\"\n  ([separator open close]\n   (make-separator separator open close identity))\n  ([separator open close transformer]\n   (let [separator (seq separator)]  ;; allow char seq or string\n     (fn [text state]\n       (if (:code state)\n         [text state]\n         (loop [out       []\n                buf       []\n                tokens    (partition-by (partial = (first separator)) (seq text))\n                cur-state (assoc state :found-token false :in-tag? false)]\n           (cond\n             (empty? tokens)\n             [(string/join (into (if (:found-token cur-state) (into out separator) out) buf))\n              (dissoc cur-state :found-token)]\n\n             (:found-token cur-state)\n             (if (= (first tokens) separator)\n               (let [[new-buf new-state]\n                     (if (identical? transformer identity)\n                       ;; Skip the buf->string->buf conversions in the common\n                       ;; case.\n                       [buf cur-state]\n                       (let [[s new-state] (transformer (string/join buf) cur-state)]\n                         [(seq s) new-state]))]\n                 (recur (vec (concat out (seq open) new-buf (seq close)))\n                        []\n                        (rest tokens)\n                        (assoc new-state :found-token false)))\n               (recur out\n                      (into buf (first tokens))\n                      (rest tokens)\n                      cur-state))\n\n             (and (= (first tokens) separator) (not (:in-tag? cur-state)))\n             (recur out buf (rest tokens) (assoc cur-state :found-token true))\n\n             :default\n             (recur (into out (first tokens)) buf (rest tokens) (assoc cur-state :in-tag? (open-html-tags (:in-tag? cur-state) (first tokens)))))))))))\n\n(defn escape-code-transformer [text state]\n  [(escape-code text) state])\n\n;; Not used any more internally; kept around just in case third party code\n;; depends on this.\n(defn separator [escape? text open close separator state]\n  ((make-separator separator open close (if escape? escape-code-transformer identity))\n   text state))\n\n(def strong (make-separator \"**\" \"<strong>\" \"</strong>\"))\n\n(def bold-italic (make-separator \"***\" \"<b><i>\" \"</i></b>\"))\n\n(def bold (make-separator \"__\" \"<b>\" \"</b>\"))\n\n(def em (make-separator \"*\" \"<em>\" \"</em>\"))\n\n(def italics (make-separator \"_\" \"<i>\" \"</i>\"))\n\n(def strikethrough (make-separator \"~~\" \"<del>\" \"</del>\"))\n\n(def inline-code (make-separator \"`\" \"<code>\" \"</code>\" escape-code-transformer))\n\n(defn inhibit [text state]\n  (if *inhibit-separator*\n    ((make-separator *inhibit-separator* \"\" \"\" freeze-string)\n     text state)\n    [text state]))\n\n(defn escape-inhibit-separator [text state]\n  [(if *inhibit-separator*\n     (string/replace text\n                     (string/join (concat *inhibit-separator* *inhibit-separator*))\n                     (string/join *inhibit-separator*))\n     text)\n   state])\n\n(defn heading-text [text]\n  (-> (clojure.string/replace text #\"^([ ]+)?[#]+\" \"\")\n      (clojure.string/replace #\"[#]+$\" \"\")\n      string/trim))\n\n(defn heading-level [text]\n  (let [num-hashes (count (filter #(not= \\space %) (take-while #(or (= \\# %) (= \\space %)) (seq text))))]\n    (if (pos? num-hashes) num-hashes)))\n\n(defn make-heading [text heading-anchors]\n  (when-let [heading (heading-level text)]\n    (let [text (heading-text text)]\n      ;; We do not need to process the id string, HTML5 ids can contain anything except the space character.\n      ;; (https://www.w3.org/TR/html5/dom.html#the-id-attribute)\n      (str \"<h\" heading (when heading-anchors (str \" id=\\\"\" (-> text string/lower-case (string/replace \" \" \"&#95;\")) \"\\\"\")) \">\"\n           text \"</h\" heading \">\"))))\n\n(defn dashes [text state]\n  [(if (or (:code state) (:codeblock state))\n     text\n     (-> text\n         (string/replace #\"\\-\\-\\-\" \"&mdash;\")\n         (string/replace #\"\\-\\-\" \"&ndash;\")\n         (string/replace #\"<code>.*</code>\"\n                         (fn [s](-> s\n                                    (string/replace #\"&mdash;\" \"---\")\n                                    (string/replace #\"&ndash;\" \"--\"))))))\n   state])\n"]}