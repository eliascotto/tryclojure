{"version":3,"sources":["sci/impl/core_protocols.cljc"],"mappings":"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","names":["js/sci","js/sci.impl","js/sci.impl.core-protocols","js/sci.impl.core-protocols.-deref","method-table__4747__auto__","cljs.core.atom","prefer-table__4748__auto__","method-cache__4749__auto__","cached-hierarchy__4750__auto__","hierarchy__4751__auto__","cljs.core.get","fexpr__48018","cljs.core/MultiFn","cljs.core.symbol","sci.impl.core-protocols/-deref","sci.impl.types/type-impl","ref","methods","sci.impl.types/getMethods","fexpr__48027","sci.impl.core-protocols/ideref-default","cljs.core/deref","sci.impl.core-protocols/deref*","x","sci.impl.core-protocols/cljs-core-ns","sci.impl.vars/->SciNamespace","sci.impl.core-protocols/deref-protocol","sci.impl.vars.new_var","cljs.core/IDeref","js/sci.impl.core-protocols.-swap!","fexpr__48054","sci.impl.core-protocols/-swap!","js/sci.impl.core-protocols.-reset!","fexpr__48063","sci.impl.core-protocols/-reset!","f","fexpr__48078","a1","fexpr__48081","a2","fexpr__48082","args","cljs.core.apply","v","fexpr__48102","sci.impl.core-protocols/iatom-defaults","cljs.core/swap!","cljs.core/reset!","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","sci.impl.core-protocols/swap!*","seq48112","G__48113","cljs.core/first","cljs.core/next","G__48114","self__4851__auto__","sci.impl.core-protocols/reset!*","sci.impl.core-protocols/swap-protocol","cljs.core/ISwap","sci.impl.core-protocols/reset-protocol","cljs.core/IReset","sci.impl.core-protocols/defaults","cljs.core/set","cljs.core.conj"],"sourcesContent":["(ns sci.impl.core-protocols\n  {:no-doc true}\n  (:refer-clojure :exclude [deref -deref -swap! -reset!])\n  (:require [sci.impl.types :as types]\n            [sci.impl.vars :as vars]))\n\n\n;;;; IDeref\n\n(defmulti #?(:clj deref :cljs -deref) types/type-impl)\n\n(defmethod #?(:clj deref :cljs -deref) :sci.impl.protocols/reified [ref]\n  (let [methods (types/getMethods ref)]\n    ((get methods #?(:clj 'deref :cljs '-deref)) ref)))\n\n(def ideref-default\n  (defmethod #?(:clj deref :cljs -deref) :default [ref]\n    (clojure.core/deref ref)))\n\n(defn deref*\n  ([x]\n   #?(:clj (deref x)\n      :cljs (-deref x)))\n  #?(:clj\n     ([x & args]\n      (apply clojure.core/deref x args))))\n\n#?(:clj\n   (def clj-lang-ns (vars/->SciNamespace 'clojure.lang nil)))\n#?(:cljs\n   (def cljs-core-ns (vars/->SciNamespace 'cljs.core nil)))\n\n(def deref-protocol\n  #?(:clj\n     (vars/new-var\n      'clojure.lang.IDeref\n      {:class clojure.lang.IDeref\n       :methods #{deref}\n       :ns clj-lang-ns}\n      {:ns clj-lang-ns})\n     :cljs\n     (vars/new-var\n      'cljs.core.IDeref\n      {:protocol IDeref\n       :methods #{-deref}\n       :ns cljs-core-ns}\n      {:ns cljs-core-ns})))\n\n;;;; end IDeref\n\n;;;; IAtom\n\n;; ;; You can use multiarity in multimethods\n;; (defmulti foo (fn [x & _] x))\n\n;; (defmethod foo :default [_ & _] \"DEFAULT VALUE DISPACHED\")\n\n;; ;; Like a standar multi-arity function\n;; (defmethod foo :bar\n;;   ([_ _] \"ONE ARGUMENT\")\n;;   ([_ _ _] \"TWO ARGUMENTs\")\n;;   ([_ _ _ _] \"THREE ARGUMENTs\")\n;;   ([_ _ _ _ & more] (cl-format nil \"~d ARGUMENTS\" (+ 3 (count more)))))\n\n(defmulti #?(:clj swap :cljs -swap!) types/type-impl)\n(defmulti #?(:clj reset :cljs -reset!) types/type-impl)\n#?(:clj (defmulti compareAndSet types/type-impl))\n#?(:clj (defmulti swapVals types/type-impl))\n#?(:clj (defmulti resetVals types/type-impl))\n\n;;;; Protocol methods\n\n(defmethod #?(:clj swap :cljs -swap!) :sci.impl.protocols/reified\n  ([ref f]\n   (let [methods (types/getMethods ref)]\n     ((get methods #?(:clj 'swap :cljs '-swap!)) ref f)))\n  ([ref f a1]\n   (let [methods (types/getMethods ref)]\n     ((get methods #?(:clj 'swap :cljs '-swap!)) ref f a1)))\n  ([ref f a1 a2]\n   (let [methods (types/getMethods ref)]\n     ((get methods #?(:clj 'swap :cljs '-swap!)) ref f a1 a2)))\n  ([ref f a1 a2 & args]\n   (let [methods (types/getMethods ref)]\n     (apply (get methods #?(:clj 'swap :cljs '-swap!)) ref f a1 a2 args))))\n\n(defmethod #?(:clj reset :cljs -reset!) :sci.impl.protocols/reified [ref v]\n  (let [methods (types/getMethods ref)]\n    ((get methods #?(:clj 'reset :cljs '-reset!)) ref v)))\n\n#?(:clj\n   (defmethod compareAndSet :sci.impl.protocols/reified [ref old new]\n     (let [methods (types/getMethods ref)]\n       ((get methods 'compareAndSet) ref old new))))\n\n#?(:clj\n   (defmethod swapVals :sci.impl.protocols/reified\n     ([ref f]\n      (let [methods (types/getMethods ref)]\n        ((get methods 'swapVals) ref f)))\n     ([ref f a1]\n      (let [methods (types/getMethods ref)]\n        ((get methods 'swapVals) ref f a1)))\n     ([ref f a1 a2]\n      (let [methods (types/getMethods ref)]\n        ((get methods 'swapVals) ref f a1 a2)))\n     ([ref f a1 a2 & args]\n      (let [methods (types/getMethods ref)]\n        (apply (get methods 'swapVals) ref f a1 a2 args)))))\n\n#?(:clj\n   (defmethod resetVals :sci.impl.protocols/reified [ref v]\n     (let [methods (types/getMethods ref)]\n       ((get methods 'resetVals) ref v))))\n\n;;;; Defaults\n\n(def iatom-defaults\n  [(defmethod #?(:clj swap :cljs -swap!) :default [ref f & args]\n     ;; TODO: optimize arities\n     (apply clojure.core/swap! ref f args))\n\n   (defmethod #?(:clj reset :cljs -reset!) :default [ref v]\n     (reset! ref v))\n\n   #?(:clj\n      (defmethod compareAndSet :default [ref old new]\n        (compare-and-set! ref old new)))\n\n   #?(:clj\n      (defmethod swapVals :default [ref & args]\n        (apply swap-vals! ref args)))\n\n   #?(:clj\n      (defmethod resetVals :default [ref v]\n        (reset-vals! ref v)))])\n\n;;;; Re-routing\n\n(defn swap!* [ref f & args]\n  ;; TODO: optimize arities - maybe test first how much this matters at all\n  ;; For CLJ I guess we can directly use the multimethods\n  (if args\n    (apply #?(:clj swap :cljs -swap!) ref f args)\n    (#?(:clj swap :cljs -swap!) ref f)))\n\n(defn reset!* [ref v]\n  (#?(:clj reset :cljs -reset!) ref v))\n\n#?(:clj\n   (defn compare-and-set!* [ref old new]\n     (compareAndSet ref old new)))\n\n#?(:clj\n   (defn swap-vals!* [ref f & args]\n     (apply swapVals ref f args)))\n\n#?(:clj\n   (defn reset-vals!* [ref v]\n     (resetVals ref v)))\n\n;;;; Protocol vars\n\n(def swap-protocol\n  #?(:clj\n     (vars/new-var\n      'clojure.lang.IAtom\n      {:class clojure.lang.IAtom\n       :methods #{swap, reset, compareAndSet}\n       :ns clj-lang-ns}\n      {:ns clj-lang-ns})\n     :cljs\n     (vars/new-var\n      'cljs.core.ISwap\n      {:protocol ISwap\n       :methods #{-swap!}\n       :ns cljs-core-ns}\n      {:ns cljs-core-ns})))\n\n#?(:cljs\n   (def reset-protocol\n     (vars/new-var\n      'cljs.core.IReset\n      {:protocol IReset\n       :methods #{-reset!}\n       :ns cljs-core-ns}\n      {:ns cljs-core-ns})))\n\n#?(:clj\n   (def iatom2-protocol\n     (vars/new-var\n      'clojure.lang.IAtom2\n      {:class clojure.lang.IAtom2\n       :methods #{swap, reset, compareAndSet, swapVals, resetVals}\n       :ns clj-lang-ns}\n      {:ns clj-lang-ns})))\n\n;;;; end IAtom\n\n(def defaults (set (conj iatom-defaults ideref-default)))\n"]}